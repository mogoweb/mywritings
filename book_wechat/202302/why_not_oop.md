Object-Oriented Programming — The Trillion Dollar Disaster

https://betterprogramming.pub/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7

面向对象编程——万亿美元的灾难

为什么是时候从 OOP 继续前进了

许多人认为 OOP 是计算机科学皇冠上的明珠。 代码组织的终极解决方案。 我们所有问题的终结。 编写程序的唯一正确方法。 编程的独一真神亲自赐予我们……

直到……事实并非如此，人们开始屈服于抽象的重压和混合共享的可变对象的复杂图形。 宝贵的时间和脑力被花在思考“抽象”和“设计模式”上，而不是解决现实世界的问题。

许多人批评面向对象编程，包括非常杰出的软件工程师。 哎呀，甚至 OOP 的发明者本人也是现代 OOP 的著名批评家！

每个软件开发人员的最终目标应该是编写可靠的代码。 如果代码有问题且不可靠，其他一切都不重要。 编写可靠代码的最佳方式是什么？ 简单。 简单是复杂的对立面。 因此，我们作为软件开发人员的首要责任应该是降低代码复杂性。

免责声明

老实说，我不是面向对象的狂热粉丝。 当然，这篇文章是有偏见的。 但是，我有充分的理由不喜欢 OOP。

我也明白对 OOP 的批评是一个非常敏感的话题——我可能会冒犯很多读者。 但是，我正在做我认为正确的事情。 我的目标不是冒犯，而是提高人们对 OOP 引入的问题的认识。

我不是在批评 Alan Kay 的 OOP——他是个天才。 我希望 OOP 按照他设计的方式实现。 我批评现代 Java/C# 的 OOP 方法。

我认为 OOP 被许多人视为代码组织的事实标准是不正确的，包括那些处于非常高级技术职位的人。 许多主流语言不提供除 OOP 之外的任何其他代码组织替代方案，这也是不可接受的。

见鬼，我过去在处理 OOP 项目时自己也很挣扎。 而且我不知道为什么我这么挣扎。 也许我不够好？ 我必须学习更多的设计模式（我认为）！ 最终，我完全筋疲力尽了。

这篇文章总结了我从面向对象到函数式编程长达十年的亲身经历。 不幸的是，无论我多么努力，我都找不到 OOP 的用例。 我亲眼见过 OOP 项目失败，因为它们变得太复杂而无法维护。

TLDR
面向对象的程序作为正确程序的替代品提供……

— Edsger W. Dijkstra，计算机科学先驱


塞巴斯蒂安·赫尔曼 (Sebastian Herrmann) 在 Unsplash 上拍摄的照片
面向对象编程的创建是为了一个目标——管理过程代码库的复杂性。 换句话说，它应该改进代码组织。 没有客观和公开的证据表明 OOP 比普通的过程编程更好。

痛苦的事实是，OOP 未能完成它打算解决的唯一任务。 它在纸面上看起来不错——我们有清晰的动物、狗、人等层次结构。但是，一旦应用程序的复杂性开始增加，它就会变得平淡无奇。 它没有降低复杂性，而是鼓励随意共享可变状态，并通过其众多的设计模式引入了额外的复杂性。 OOP 使常见的开发实践（如重构和测试）变得不必要地困难。

有些人可能不同意我的看法，但事实是现代 Java/C# OOP 从未被正确设计过。 它从来没有出自合适的研究机构（与 Haskell/FP 相比）。 Lambda 演算为函数式编程提供了完整的理论基础。 OOP 没有与之相匹配的东西。

使用 OOP 在短期内似乎是无害的，尤其是在新建项目中。 但是使用 OOP 的长期后果是什么？ OOP 是一颗定时炸弹，当代码库变得足够大时，它会在未来的某个时候爆炸。

项目被推迟，最后期限被错过，开发人员精疲力尽，添加新功能几乎是不可能的。 该组织将代码库标记为“遗留代码库”，开发团队计划重写。

OOP 对人脑来说并不自然，我们的思维过程以“做”事情为中心——散步、与朋友交谈、吃披萨。 我们的大脑已经进化为可以做事，而不是将世界组织成抽象对象的复杂层次结构。

OOP 代码是不确定的——与函数式编程不同，我们不能保证在给定相同输入的情况下获得相同的输出。 这使得对程序的推理变得非常困难。 作为一个过度简化的例子，2+2 或 calculator.Add(2, 2) 的输出大部分等于四，但有时它可能等于三、五，甚至可能等于 1004。计算器对象的依赖项可能会改变 以微妙但深刻的方式计算的结果。 哎呀……

需要一个弹性框架
好的程序员写出好的代码，坏的程序员写出糟糕的代码，无论编程范式如何。 然而，编程范式应该限制糟糕的程序员做太多的破坏。 当然，这不是你，因为你已经在阅读这篇文章并努力学习了。 糟糕的程序员从来没有时间学习，他们只会发疯似的按键盘上的任意按钮。 不管你喜不喜欢，你都会和糟糕的程序员一起工作，他们中的一些人真的很糟糕。 而且，不幸的是，OOP 没有足够的约束来防止糟糕的程序员造成太大的破坏。 哎呀……

我不认为自己是一个糟糕的程序员，但如果没有一个强大的框架作为我工作的基础，即使我也无法编写出好的代码。 是的，有些框架关注一些非常特殊的问题（例如 Angular 或 ASP.Net）。

我不是在谈论软件框架。 我说的是框架的更抽象的字典定义：“一个基本的支持结构”——框架关注更抽象的事情，比如代码组织和处理代码复杂性。 尽管面向对象和函数式编程都是编程范式，但它们也是非常高级的框架。

限制我们的选择
C++ 是一种可怕的 [面向对象] 语言……将您的项目限制为 C 意味着人们不会用任何愚蠢的“对象模型”c&@p 搞砸事情。
——Linus Torvalds，Linux 的创造者

Linus Torvalds 因其对 C++ 和 OOP 的公开批评而广为人知。 他 100% 正确的一件事是限制程序员做出的选择。 事实上，程序员的选择越少，他们的代码就越有弹性。 在上面的引述中，Linus Torvalds 强烈建议有一个好的框架作为我们代码的基础。

许多人不喜欢道路上的速度限制，但它们对于帮助防止人们撞死至关重要。 同样，一个好的编程框架应该提供防止我们做傻事的机制。

一个好的编程框架可以帮助我们写出可靠的代码。 首先，它应该通过提供以下内容来帮助降低复杂性：

模块化和可重用性
适当的状态隔离
高信噪比
不幸的是，OOP 为开发人员提供了太多的工具和选择，而没有施加正确的限制。 尽管 OOP 承诺解决模块化问题并提高可重用性，但它未能兑现其承诺（稍后会详细介绍）。 OOP 代码鼓励使用共享可变状态，这已被多次证明是不安全的。 OOP 通常需要大量样板代码（低信噪比）。

函数式编程
什么是函数式编程？ 有人认为它是一种高度复杂的编程范式，只适用于学术界，并不适合“现实世界”。 这与事实相去甚远！

是的，函数式编程具有强大的数学基础，并植根于 lambda 演算。 然而，它的大部分想法都是作为对更主流编程语言弱点的回应而出现的。 函数是函数式编程的核心抽象。 如果使用得当，函数可以提供一定程度的代码模块化和可重用性，这在 OOP 中是前所未有的。 它甚至具有解决可空性问题的设计模式，并提供了一种更好的错误处理方式。

函数式编程做得很好的一件事是它帮助我们编写可靠的软件。 对调试器的需求几乎完全消失了。 是的，无需单步执行您的代码并观察变量。 我个人已经很长时间没有接触调试器了。

最好的部分？ 如果你已经知道如何使用函数，那么你已经是一个函数式程序员了。 您只需要学习如何充分利用这些功能！

我不是在鼓吹函数式编程，我真的不在乎你使用什么编程范式来编写你的代码。 我只是想传达函数式编程提供的机制，以解决 OOP/命令式编程固有的问题。

我们完全错了 OOP
很抱歉，我很久以前就为这个话题创造了“对象”这个词，因为它让很多人关注次要的想法。 重要的想法是消息传递。
——Alan Kay，OOP 的发明者

Erlang 通常不被认为是一种面向对象的语言。 但可能 Erlang 是目前唯一的主流面向对象语言。 是的，Smalltalk 当然是一种合适的 OOP 语言 — 然而，它并未得到广泛使用。 Smalltalk 和 Erlang 都按照 OOP 的发明者 Alan Kay 最初打算的方式使用 OOP。

讯息
Alan Kay 在 1960 年代创造了“面向对象编程”一词。 他有生物学背景，并试图让计算机程序像活细胞一样进行交流。


Muukii 在 Unsplash 上拍摄的照片
Alan Kay 的伟大想法是让独立的程序（细胞）通过相互发送消息进行通信。 独立程序的状态永远不会与外界共享（封装）。

就是这样。 OOP 从未打算拥有诸如继承、多态、“new”关键字和无数设计模式之类的东西。

OOP 的最纯粹形式
Erlang 是最纯粹形式的 OOP。 与更主流的语言不同，它专注于 OOP 的核心思想——消息传递。 在 Erlang 中，对象通过在对象之间传递不可变消息来进行通信。

与方法调用相比，是否有证据表明不可变消息是一种更好的方法？

当然好！ Erlang 可能是世界上最可靠的语言。 它为世界上大部分的电信（以及互联网）基础设施提供动力。 一些用 Erlang 编写的系统具有 99.9999999% 的可靠性（你没看错——九个九）。

代码复杂度
使用受 OOP 影响的编程语言，计算机软件变得更加冗长、可读性差、描述性差，并且更难修改和维护。

— 理查德·曼斯菲尔德

软件开发最重要的方面是降低代码的复杂性。 时期。 如果代码库变得无法维护，那么任何花哨的功能都无关紧要。 如果代码库变得过于复杂和难以维护，即使 100% 的测试覆盖率也毫无价值。

是什么让代码库变得复杂？ 有很多事情需要考虑，但在我看来，最主要的罪魁祸首是：共享可变状态、错误的抽象和低信噪比（通常由样板代码引起）。 所有这些在 OOP 中都很流行。

国家问题

Mika Baumeister 在 Unsplash 上拍摄的照片
什么是状态？ 简单地说，状态是存储在内存中的任何临时数据。 想想 OOP 中的变量或字段/属性。 命令式编程（包括 OOP）根据程序状态和对该状态的更改来描述计算。 相反，声明式（函数式）编程描述了所需的结果，并且不明确指定对状态的更改。

可变状态——精神上的杂耍行为
我认为大型面向对象的程序在构建可变对象的大型对象图时会与日益增加的复杂性作斗争。 你知道，试图理解并牢记调用方法时会发生什么以及副作用是什么。

——Rich Hickey，Clojure 的创造者


图片来源：https://www.flickr.com/photos/48137825@N05/8707342427
状态本身是非常无害的。 然而，可变状态是罪魁祸首。 特别是如果它是共享的。 究竟什么是可变状态？ 任何可以改变的状态。 想想 OOP 中的变量或字段。

现实世界的例子，拜托！

你有一张白纸，你在上面写了一个笔记，最后你得到了不同状态（文本）的同一张纸。 实际上，你已经改变了那张纸的状态。

这在现实世界中完全没问题，因为没有其他人可能会关心那张纸。 除非这张纸是蒙娜丽莎的原画。

人脑的局限性

为什么可变状态是个大问题？ 人脑是已知宇宙中最强大的机器。 然而，我们的大脑在处理状态时真的很糟糕，因为我们的工作记忆中一次只能保存大约 5 个项目。 如果您只考虑代码的作用，而不是它在代码库中更改的变量，那么对一段代码进行推理会容易得多。

使用可变状态编程是一种精神上的杂耍行为️。 我不了解你，但我可能会玩两个球。 给我三个或更多的球，我一定会把它们全部扔掉。 那么，为什么我们每天都在努力进行这种精神上的杂耍呢？

不幸的是，可变状态的心理处理是 OOP 的核心。 对象上存在方法的唯一目的是改变同一个对象。

分散状态

Markus Spiske 在 Unsplash 上拍摄的照片
OOP 通过在整个程序中散布状态，使代码组织问题变得更糟。 然后分散状态在各种对象之间混合共享。

现实世界的例子，拜托！

让我们暂时忘记我们都是成年人，假装我们正在尝试组装一辆很酷的乐高卡车。

然而，有一个问题——所有卡车零件都随机地与您其他乐高玩具的零件混合在一起。 它们又被随机地放在 50 个不同的盒子里。 而且你不能将你的卡车零件组合在一起——你必须记住各种卡车零件的位置，并且只能将它们一个一个地取出来。

是的，你最终会组装那辆卡车，但你需要多长时间？

这与编程有什么关系？

在函数式编程中，状态通常是孤立的。 你总是知道某些状态来自哪里。 状态永远不会分散在您的不同功能中。 在 OOP 中，每个对象都有自己的状态，在构建程序时，您必须牢记当前正在使用的所有对象的状态。

为了让我们的生活更轻松，最好只让代码库的一小部分处理状态。 让你的应用程序的核心部分是无状态和纯粹的。 这实际上是前端（又名 Redux）上的通量模式取得巨大成功的主要原因。

乱七八糟的共享状态
好像我们的生活还不够艰难，因为有分散的可变状态，OOP 更进了一步！

现实世界的例子，拜托！

现实世界中的可变状态几乎从来都不是问题，因为事情是保密的，从不共享。 这是工作中的“适当封装”。 想象一位画家正在创作下一幅蒙娜丽莎的画作。 他独自创作这幅画，完成，然后以数百万美元的价格出售他的杰作。

现在，他厌倦了所有这些钱，并决定做一些不同的事情。 他认为举办绘画派对是个好主意。 他邀请了他的朋友精灵、甘道夫、警察和僵尸来帮助他。 团队合作！ 他们同时开始在同一张画布上作画。 当然，没有什么好结果——这幅画完全是一场灾难！

共享可变状态在现实世界中毫无意义。 然而，这正是 OOP 程序中发生的事情——状态在各种对象之间随意共享，并且它们以它们认为合适的任何方式改变它。 随着代码库的不断增长，这反过来又使对程序的推理变得越来越困难。

并发问题
OOP 代码中可变状态的混杂共享使得并行化此类代码几乎不可能。 为了解决这个问题，已经发明了复杂的机制。 已经发明了线程锁定、互斥和许多其他机制。 当然，这种复杂的方法有其自身的缺点——死锁、缺乏可组合性、调试多线程代码非常困难且耗时。 我什至不是在谈论因使用此类并发机制而导致的复杂性增加。

并非所有的国家都是邪恶的
所有的国家都是邪恶的吗？ 不，艾伦凯状态很可能不是邪恶的！ 如果状态突变是真正孤立的（而不是“OOP-way”孤立的），则状态突变可能没问题。

拥有不可变的数据传输对象也完全没问题。 这里的关键是“不可变”。 然后使用此类对象在函数之间传递数据。

然而，这样的对象也会使 OOP 方法和属性完全多余。 如果一个对象不能被改变，那么拥有它的方法和属性有什么用呢？

可变性是 OOP 固有的
有些人可能会争辩说可变状态是 OOP 中的设计选择，而不是义务。 这个说法有问题。 这不是设计选择，但几乎是唯一的选择。 是的，可以将不可变对象传递给 Java/C# 中的方法，但很少这样做，因为大多数开发人员默认为数据突变。 即使开发人员试图在他们的 OOP 程序中正确使用不可变性，这些语言也没有为不可变性和有效地处理不可变数据（即持久数据结构）提供内置机制。

是的，我们可以确保对象仅通过传递不可变消息进行通信，并且从不传递任何引用（很少这样做）。 这样的程序会比主流的 OOP 更可靠。 但是，一旦收到消息，对象仍然必须改变自己的状态。 消息是一种副作用，它的唯一目的是引起变化。 如果消息不能改变其他对象的状态，那么消息将毫无用处。

在不引起状态突变的情况下使用 OOP 是不可能的。

封装的特洛伊木马

Pexels 上的 Jamie McInall 拍摄的照片
我们被告知封装是 OOP 的最大好处之一。 它应该保护对象的内部状态免受外部访问。 不过这有一个小问题。 它不起作用。

封装是 OOP 的特洛伊木马。 它通过使它看起来安全来推销共享可变状态的想法。 封装允许（甚至鼓励）不安全的代码潜入我们的代码库，使代码库从内部腐烂。

全局状态问题
我们被告知，全局状态是万恶之源。 应该不惜一切代价避免它。 我们从未被告知的是，封装实际上是美化的全局状态。

为了使代码更高效，对象不是通过它们的值传递的，而是通过它们的引用传递的。 这就是“依赖注入”失败的地方。

让我解释。 每当我们在 OOP 中创建一个对象时，我们都会将对其依赖项的引用传递给构造函数。 这些依赖项也有自己的内部状态。 新创建的对象愉快地在其内部状态中存储对这些依赖项的引用，然后愉快地以任何它喜欢的方式修改它们。 它还将这些引用传递给它可能最终使用的任何其他内容。

这创建了一个复杂的图表，其中包含混合共享的对象，这些对象最终都改变了彼此的状态。 这反过来会导致巨大的问题，因为几乎不可能看到是什么导致了程序状态的改变。 尝试调试此类状态更改可能会浪费几天时间。 如果您不必处理并发问题，那您就很幸运了（稍后会详细介绍）。

方法/属性
提供对特定字段的访问的方法或属性并不比直接更改字段的值更好。 是否使用花哨的属性或方法来改变对象的状态并不重要——结果是一样的：改变状态。

真实世界建模的问题

Markus Spiske 在 Unsplash 上拍摄的照片
有人说 OOP 试图模拟现实世界。 这根本不是真的——OOP 在现实世界中没有任何关系。 试图将程序建模为对象可能是最大的 OOP 错误之一。

现实世界没有等级制度
OOP 试图将一切建模为对象的层次结构。 不幸的是，这不是现实世界中的事情。 现实世界中的对象通过消息相互交互，但它们大多是相互独立的。

现实世界中的继承
OOP 继承不是根据现实世界建模的。 现实世界中的父对象无法在运行时更改子对象的行为。 即使你从父母那里继承了你的 DNA，他们也无法随心所欲地改变你的 DNA。 您不会从父母那里继承“行为”，而是发展自己的行为。 而且你无法“超越”你父母的行为。

现实世界没有方法
你正在写的那张纸有“写”的方法吗？ 不！ 你拿一张空纸，拿起笔，写一些文字。 作为一个人，你也没有“写”的方法——你根据外部事件或你的内心想法来决定写一些文本。

名词王国
对象以不可分割的单元将函数和数据结构绑定在一起。 我认为这是一个根本错误，因为函数和数据结构属于完全不同的世界。

——Joe Armstrong，Erlang 的创造者


Cederic X 在 Unsplash 上拍摄的照片
对象（或名词）是 OOP 的核心。 OOP 的一个基本限制是它强制所有内容都变成名词。 并不是所有的东西都应该被建模为名词。 操作（功能）不应建模为对象。 当我们只需要一个将两个数字相乘的函数时，为什么我们被迫创建一个 Multiplier 类？ 简单地有一个乘法函数，让数据成为数据，让函数成为函数！

在非 OOP 语言中，将数据保存到文件等琐碎的事情非常简单——非常类似于用简单的英语描述动作的方式。

现实世界的例子，拜托！

当然，回到画家的例子，画家拥有一个绘画工厂。 他雇用了专门的 BrushManager 、ColorManager、CanvasManager 和 MonaLisaProvider。 他的好朋友僵尸使用了 BrainConsumingStrategy 。 这些对象又定义了以下方法：CreatePainting、FindBrush、PickColor、CallMonaLisa 和 ConsumeBrainz。

当然，这纯属愚蠢，在现实世界中绝不会发生。 为简单的绘画行为创造了多少不必要的复杂性？

当允许函数与对象分开存在时，无需发明奇怪的概念来保存您的函数。

单元测试

照片由 Ani Kolleshi 在 Unsplash 上拍摄
自动化测试是开发过程的重要组成部分，并且极大地有助于防止回归（即，将错误引入现有代码）。 单元测试在自动化测试过程中起着巨大的作用。

有些人可能不同意，但是众所周知，OOP 代码很难进行单元测试。 单元测试假定单独测试事物，并使方法可单元测试：

它的依赖项必须提取到一个单独的类中。
为新创建的类创建一个接口。
声明字段以保存新创建的类的实例。
使用模拟框架来模拟依赖项。
使用依赖注入框架来注入依赖项。
仅仅为了使一段代码可测试，还需要创建多少复杂性？ 仅仅为了使一些代码可测试就浪费了多少时间？

> PS 我们还必须实例化整个类才能测试单个方法。 这还将引入其所有父类的代码。

使用 OOP，为遗留代码编写测试更加困难——几乎是不可能的。 围绕测试遗留 OOP 代码的问题创建了整个公司 (TypeMock)。

样板代码
当谈到信噪比时，样板代码可能是最大的违规者。 样板代码是让程序编译所需的“噪音”。 样板代码需要花费时间来编写，并且由于增加了噪音而使代码库的可读性降低。

虽然“针对接口而非实现编程”是 OOP 中推荐的方法，但并非所有内容都应成为接口。 出于可测试性的唯一目的，我们不得不求助于在整个代码库中使用接口。 我们可能还必须使用依赖注入，这进一步引入了不必要的复杂性。

测试私有方法
有人说不应该测试私有方法……我倾向于不同意，单元测试被称为“单元”是有原因的——单独测试小的代码单元。 然而，在 OOP 中测试私有方法几乎是不可能的。 我们不应该仅仅为了可测试性而将私有方法设为内部。

为了实现私有方法的可测试性，通常必须将它们提取到一个单独的对象中。 这反过来又引入了不必要的复杂性和样板代码。

重构
重构是开发人员日常工作的重要组成部分。 具有讽刺意味的是，OOP 代码是出了名的难以重构。 重构应该使代码不那么复杂，并且更易于维护。 相反，重构的 OOP 代码变得更加复杂——为了使代码可测试，我们必须使用依赖注入，并为重构的类创建一个接口。 即便如此，如果没有像 Resharper 这样的专用工具，重构 OOP 代码也非常困难。

在上面的简单示例中，仅仅为了提取一个方法，行数就增加了一倍多。 为什么重构会产生更多的复杂性，而重构代码首先是为了降低复杂性？

将此与 JavaScript 中非 OOP 代码的类似重构进行对比：

代码实际上保持不变——我们只是将 isValidInput 函数移动到不同的文件并添加一行来导入该函数。 为了可测试性，我们还在函数签名中添加了 _isValidInput。

这是一个简单的例子，但在实践中，随着代码库变大，复杂性呈指数级增长。

这还不是全部。 重构 OOP 代码风险极大。 复杂的依赖图和状态散布在 OOP 代码库中，使人脑无法考虑所有潜在问题。

创可贴

图片来源：来自 Pexels 的 Pixabay 照片
当某些东西不起作用时我们该怎么办？ 很简单，我们只有两个选择——扔掉它或尝试修复它。 OOP 是不能轻易丢弃的东西，数以百万计的开发人员都接受过 OOP 培训。 全世界有数百万组织正在使用 OOP。

您现在可能会看到 OOP 并没有真正发挥作用，它使我们的代码变得复杂且不可靠。 而且你并不孤单！ 几十年来，人们一直在努力思考，试图解决 OOP 代码中普遍存在的问题。 他们提出了无数的设计模式。

设计模式
OOP 提供了一套指导方针，理论上应该允许开发人员逐步构建越来越大的系统：SOLID 原则、依赖注入、设计模式等。

不幸的是，设计模式只不过是创可贴。 它们的存在仅仅是为了解决 OOP 的缺点。 关于这个主题甚至写了无数的书。 如果他们没有为我们的代码库引入巨大的复杂性，他们就不会那么糟糕。

问题工厂
事实上，写出好的、可维护的面向对象代码是不可能的。

一方面，我们有一个不一致且似乎不遵守任何标准的 OOP 代码库。 另一方面，我们有一座过度设计的代码塔，一堆错误的抽象相互叠加。 设计模式对于构建这样的抽象塔非常有帮助。

很快，添加新功能，甚至理解所有的复杂性，都会变得越来越难。 代码库将充满诸如 SimpleBeanFactoryAwareAspectInstanceFactory、AbstractInterceptorDrivenBeanDefinitionDecorator、TransactionAwarePersistenceManagerFactoryProxyorRequestProcessorFactoryFactory 之类的东西。

必须浪费宝贵的脑力来试图理解开发人员自己创建的抽象塔。 在许多情况下，没有结构比结构不好（如果你问我）要好。

OOP 四大支柱的倒塌
OOP的四大支柱是：抽象、继承、封装和多态。

让我们一一看看它们到底是什么。


遗产
我认为缺乏可重用性的是面向对象的语言，而不是函数式语言。 因为面向对象语言的问题在于它们拥有随身携带的所有这些隐式环境。 你想要一根香蕉，但你得到的是一只拿着香蕉和整个丛林的大猩猩。

——Joe Armstrong，Erlang 的创造者

OOP 继承与现实世界无关。 实际上，继承是实现代码可重用性的较差方法。 四人组明确建议优先使用组合而不是继承。 一些现代编程语言完全避免继承。

继承有几个问题：

引入很多你的班级甚至不需要的代码（香蕉和丛林问题）。
在其他地方定义类的某些部分会使代码难以推理，尤其是在具有多级继承的情况下。
在大多数编程语言中，多重继承甚至是不可能的。 这主要使继承作为一种代码共享机制变得无用。
OOP 多态性
多态性很棒，它允许我们在运行时改变程序行为。 然而，它是计算机编程中一个非常基本的概念。 我不太清楚为什么 OOP 如此关注多态性。 OOP 多态性完成了工作，但它又一次导致了精神上的杂耍行为。 它使代码库变得更加复杂，并且对正在调用的具体方法进行推理变得非常困难。

另一方面，函数式编程允许我们以更优雅的方式实现相同的多态性……通过简单地传入定义所需运行时行为的函数。 还有什么比这更简单的呢？ 无需在多个文件（和接口）中定义一堆重载的抽象虚方法。

封装
正如我们之前讨论的，封装是 OOP 的特洛伊木马。 它实际上是一个美化的全局可变状态，使不安全的代码看起来安全。 不安全的编码实践是 OOP 程序员在日常工作中所依赖的支柱……

抽象
OOP 中的抽象试图通过向程序员隐藏不必要的细节来解决复杂性。 从理论上讲，它应该允许开发人员推理代码库而不必考虑隐藏的复杂性。

我什至不知道该说什么……一个简单概念的花哨词。 在过程/功能语言中，我们可以简单地将实现细节“隐藏”在相邻文件中。 无需将此基本行为称为“抽象”。

有关 OOP 支柱倒塌的更多详细信息，请阅读再见，面向对象编程

为什么 OOP 在行业中占主导地位？
答案很简单，爬虫类外星种族与美国国家安全局（和俄罗斯人）合谋，要将我们程序员折磨死……


Gaetano Cessati 在 Unsplash 上拍摄的照片
但说真的，Java 可能就是答案。

Java 是自 MS-DOS 以来计算领域发生的最令人苦恼的事情。

——Alan Kay，面向对象程序设计的发明者

Java很简单
1995 年首次推出时，与其他替代语言相比，Java 是一种非常简单的编程语言。 当时，编写桌面应用程序的门槛很高。 开发桌面应用程序涉及用 C 编写低级 win32 API，开发人员还必须关注手动内存管理。 另一个选择是 Visual Basic，但许多人可能不想将自己锁定在 Microsoft 生态系统中。

当 Java 被引入时，它是免费的，并且可以在所有平台上使用，因此对于许多开发人员来说是显而易见的。 诸如内置垃圾收集、友好命名的 API（与神秘的 win32 API 相比）、适当的命名空间和熟悉的类 C 语法等东西使 Java 更加易于使用。

GUI 编程也变得越来越流行，各种 UI 组件似乎很好地映射到类。 IDE 中的方法自动完成功能也让人们声称 OOP API 更易于使用。

如果 Java 没有将 OOP 强加给开发人员，也许 Java 不会这么糟糕。 Java 的其他一切似乎都不错。 它的垃圾收集、可移植性、异常处理等其他主流编程语言所缺乏的特性，在 1995 年确实很棒，

然后C#出现了
最初，微软一直严重依赖 Java。 当事情开始出现问题时（在与 Sun Microsystems 就 Java 许可问题进行了长期的法律斗争之后），Microsoft 决定投资开发自己的 Java 版本。 那是 C# 1.0 诞生的时候。 C# 作为一种语言一直被认为是“更好的 Java”。 然而，有一个大问题——它是具有相同缺陷的相同 OOP 语言，隐藏在略微改进的语法下。

微软一直在大力投资其 .NET 生态系统，其中还包括优秀的开发人员工具。 多年来，Visual Studio 可能一直是可用的最佳 IDE 之一。 这反过来又导致了 .NET 框架的广泛采用，尤其是在企业中。

最近，微软通过推广其 TypeScript，一直在大力投资浏览器生态系统。 TypeScript 很棒，因为它可以编译纯 JavaScript 并添加静态类型检查等功能。 它的不足之处在于它没有对函数结构的适当支持——没有内置的不可变数据结构，没有函数组合，没有适当的模式匹配。 TypeScript 是 OOP-first，主要是浏览器的 C#。 Anders Hejlsberg 甚至负责 C# 和 TypeScript 的设计。

函数式语言
另一方面，函数式语言从来没有得到像微软这样的大公司的支持。 F# 不算数，因为投资很小。 函数式语言的开发主要是社区驱动的。 这可能解释了 OOP 和 FP 语言之间流行程度的差异。

分手后要往前看了？
我们现在知道 OOP 是一个失败的实验。 是时候继续前进了。 作为一个社区，我们是时候承认这个想法让我们失望了，我们必须放弃它。

- 劳伦斯克鲁布纳


SpaceX 在 Unsplash 上拍摄的照片
为什么我们坚持使用从根本上来说不是最佳方式的程序组织方式？ 这是普通的无知吗？ 我怀疑，从事软件工程的人并不傻。 我们是否更担心使用诸如“设计模式”、“抽象”、“封装”、“多态”和“接口隔离”等花哨的 OOP 术语在同行面前“看起来很聪明”？ 可能不会。

我认为继续使用我们已经使用了几十年的东西真的很容易。 大多数人从未真正尝试过函数式编程。 那些拥有（像我自己）的人永远不能回去写 OOP 代码。

亨利福特曾经说过一句名言——“如果我问人们他们想要什么，他们会说更快的马”。 在软件世界中，大多数人可能想要一种“更好的 OOP 语言”。 人们可以很容易地描述他们遇到的问题（组织代码库并降低复杂性），但不是最好的解决方案。

有哪些选择？
剧透警告：函数式编程。


Harley-Davidson 在 Unsplash 上拍摄的照片
如果像函子和单子这样的术语让你有点不安，那么你并不孤单！ 如果函数式编程的某些概念具有更直观的名称，函数式编程就不会那么可怕。 函子？ 这只是我们可以用函数转换的东西，想想 list.map。 单子？ 可以链接的简单计算！

尝试函数式编程将使您成为更好的开发人员。 您最终将有时间编写解决现实世界问题的真实代码，而不必花费大部分时间思考抽象和设计模式。

你可能没有意识到这一点，但你已经是一名函数式程序员了。 您在日常工作中使用函数吗？ 是的？ 那你已经是一个函数式程序员了！ 您只需要学习如何充分利用这些功能。

Elixir 和 Elm 是两种学习曲线非常平缓的函数式语言。 它们让开发人员专注于最重要的事情——编写可靠的软件，同时消除更多传统函数式语言所具有的所有复杂性。

还有哪些选择？ 您的组织是否已经在使用 C#？ 试试 F#——它是一种了不起的函数式语言，并提供与现有 .NET 代码的出色互操作性。 使用Java？ 那么使用 Scala 或 Clojure 都是非常好的选择。 使用JavaScript？ 有了正确的指导和 linting，JavaScript 可以成为一种很好的函数式语言。

OOP 的捍卫者

Pexels 上的 Ott Maidre 拍摄的照片
我期待 OOP 的捍卫者做出某种反应。 他们会说这篇文章充满了错误。 有些人甚至可能开始骂人。 他们甚至可能称我为没有实际 OOP 经验的“初级”开发人员。 有人可能会说我的假设是错误的，例子也没有用。 任何。

他们有权发表意见。 然而，他们为 OOP 辩护的论据通常是相当薄弱的。 具有讽刺意味的是，他们中的大多数人可能从未真正用真正的函数式语言编程过。 如果你从未真正尝试过两者，那么有人怎么能在两件事之间进行比较呢？ 这样的比较不是很有用。

得墨忒耳法则不是很有用——它对解决非确定性问题没有任何作用，共享可变状态仍然是共享可变状态，无论您如何访问或改变该状态。 a.total() 并不比 a.getB().getC().total() 好多少。 它只是将问题掩盖起来。

领域驱动设计？ 这是一种有用的设计方法，它有助于解决复杂性问题。 然而，它仍然无法解决共享可变状态的根本问题。

只是工具箱中的一个工具……
我经常听到人们说 OOP 只是工具箱中的另一个工具。 是的，它是工具箱中的工具，就像马和车都是交通工具一样……毕竟，它们都有相同的用途，对吧？ 当我们可以继续骑好老马时，为什么还要使用汽车呢？

历史总是重演
这其实让我想起了一件事。 20世纪初，汽车开始取代马匹。 在 1900 年纽约的道路上只有几辆汽车，人们一直使用马匹作为交通工具。 1917 年，马路上再也没有马了。 一个巨大的产业以马匹运输为中心。 整个企业都是围绕粪便清理等事情创建的。

人们拒绝改变。 他们称汽车为另一种最终会过去的“时尚”。 毕竟，马已经存在了几个世纪！ 甚至有人要求政府干预。

这有什么关系？ 软件行业以 OOP 为中心。 数以百万计的人接受过 OOP 培训，数以百万计的公司在其代码中使用了 OOP。 当然，他们会试图诋毁任何威胁到他们生计的东西！ 这只是常识。

我们清楚地看到历史在重演——在 20 世纪是马匹与汽车，在 21 世纪是面向对象与函数式编程。