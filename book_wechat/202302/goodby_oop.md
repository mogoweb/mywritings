Goodbye, Object Oriented Programming

https://cscalfani.medium.com/goodbye-object-oriented-programming-a59cda4c0e53

几十年来，我一直在使用面向对象的语言进行编程。 我使用的第一种 OO 语言是 C++，然后是 Smalltalk，最后是 .NET 和 Java。

我热衷于利用继承、封装和多态的好处。 范式的三大支柱。

我渴望获得重用的承诺，并利用前人在这个令人兴奋的新环境中获得的智慧。

一想到将我的现实世界对象映射到它们的类中，我就无法抑制自己的兴奋，并希望整个世界都整齐地落到位。

我大错特错了。

继承，第一根倒下的支柱

乍一看，继承似乎是面向对象范式的最大好处。 所有作为示例展示给新灌输的形状层次结构的简单示例似乎都合乎逻辑。


重用是当今的流行语。 不……让它成为一年，也许永远。

我吞下了这一切，带着我新发现的洞察力冲进了这个世界。

香蕉猴丛林问题
怀着信仰和要解决的问题，我开始构建类层次结构并编写代码。 世界一切都好。

我永远不会忘记那天，我准备好通过继承现有类来兑现重用的承诺。 这是我一直在等待的时刻。

一个新项目出现了，我回想起我在上一个项目中非常喜欢的那个课程。

没问题。 重用救援。 我所要做的就是从其他项目中获取该类并使用它。

好吧……实际上……不只是那个班级。 我们需要父类。 但是……不过就是这样。

呃……等等……看起来我们也需要父母的父母……然后……我们需要所有的父母。 好吧……好吧……我来处理。 没问题。

很棒。 现在它不会编译。 为什么？？ 哦，我明白了……这个对象包含另一个对象。 所以我也需要那个。 没问题。

等等……我不只是需要那个东西。 我需要对象的父对象及其父对象的父对象，依此类推，每个包含的对象以及这些对象的所有父对象以及它们的父对象、父对象、父对象的……

啊。

Erlang 的创造者 Joe Armstrong 有一句名言：

面向对象语言的问题在于它们拥有随身携带的所有这些隐式环境。 你想要一根香蕉，但你得到的是一只拿着香蕉和整个丛林的大猩猩。

香蕉猴丛林解决方案
我可以通过不创建太深的层次结构来解决这个问题。 但是如果继承是重用的关键，那么我对该机制施加的任何限制肯定会限制重用的好处。 正确的？

正确的。

那么，一个可怜的面向对象程序员，在 Kool-aid 的健康帮助下，该怎么办？

包含和委托。 稍后会详细介绍。

钻石问题
迟早，下面的问题会浮出水面，而且根据语言的不同，会出现无法解决的问题。


大多数 OO 语言不支持这一点，尽管这似乎合乎逻辑。 在 OO 语言中支持这一点有什么困难？