# 写给开发人员的实用密码学 - 随机数

上一篇文章中介绍了消息验证码，这篇文章咱们来聊聊随机数。随机数看起来是一个很简单的概念，不论哪种编程语言都提供了简单的生成随机数的方法，有必要单独写一篇文章么？

随机数看起来简单，但在密码学中的用途非常大。比如用于加解密的密钥本质上就是一个随机数，密码学算法内部也会用到随机数。从开发者直观的角度看，随机数就是一串杂乱无序的字母、数字、符号组合，但如何生成随机数很重要，也就是说如何正确使用随机数生成算法非常重要。

在密码学中，随机性（熵）起着非常重要的作用。 在许多算法中，我们需要随机（即不可预测）的数字。 如果这些数字不是不可预测的，则算法将受到损害。
例如，假设我们需要一个密钥，它将保护我们的金融资产。 此秘密密钥应以其他任何人都不能生成或具有相同密钥的方式随机生成。 如果我们从安全的随机生成器生成密钥，则密钥将是不可预测的，并且系统将是安全的。 因此，“安全随机”仅表示“不可预测的随机”。
让我们更详细地讨论计算机科学中的随机数及其在密码学中的作用，以及伪随机数生成器（PRNG），安全伪随机生成器（CSPRNG）以及有关开发人员应如何在其中生成和使用随机数的一些准则。 他们的代码。

随机发生器
在计算机科学中，随机数通常来自伪随机数生成器（PRNG），该伪随机数生成器由某些不可预测的初始随机性（熵）初始化。 在密码术中，使用安全的PRNG（称为CSPRNG），通常将熵与PRNG和其他技术结合使用，以使生成的随机性不可预测。
伪随机数生成器（PRNG）
伪随机数生成器（PRNG）用于扩展少量的初始随机性
  进入大量伪随机性，通常用于密码系统。 请注意，PRNG不是加密安全的，并且不同于CSPRNG。
PRNG是从某个初始熵（种子）开始，并通过某种计算来计算下一个随机数的函数，而这些计算在不知道种子的情况下是无法预测的。 这种计算称为伪随机函数。

伪随机函数（对于加密不安全）通常使用内部状态。 首先，通过初始种子初始化状态。 当生成下一个随机数时，它是从内部状态（使用某种计算或公式）计算出来的，然后更改伪随机函数的内部状态（使用某种计算或公式）。 当生成下一个随机数时，将再次根据函数的内部状态进行计算，并再次更改此状态，依此类推。
以最简单的形式可以执行以下过程：

当然，可以通过某种加密哈希函数或另一种数学转换（例如Mersenne Twister（这在加密上并不安全））来更改HMAC函数，但主要思想保持不变：伪随机生成器具有内部状态，并使用一些初始值进行了初始化。随时间变化的随机性会根据当前状态改变其内部状态并生成伪随机数。
好的随机数生成器应该是快速的，并且应该生成统计随机性（请参阅Diehard测试），即在一段时间内所有数字的生成机会均应相同。这还不够，因此CSPRNG有更高的要求。
上面提到的基于HMAC（密钥+计数器）生成随机伪数（带有一些复杂性）的想法被称为HMAC_DRGB算法，在安全标准NIST 800-90A中进行了描述。
初始熵（种子）
为了安全起见，PRNG（统计上是随机的）应该从真正随机的初始种子开始，这绝对是不可预测的。如果种子是可预测的，它将生成可预测的随机数序列，并且整个随机生成过程将是不安全的。这就是为什么在开始时拥有不可预测的随机性（安全种子）非常重要的原因。
如何以安全的方式初始化伪随机生成器？答案很简单：收集随机性（熵）。

熵
在计算机科学中，“熵”是指不可预测的随机性，通常以位为单位进行度量。例如，如果您移动计算机的鼠标，它将生成一些难以预测的事件，例如鼠标光标的开始位置和结束位置。如果我们假设鼠标在[0 ... 255]像素范围内更改了位置，则从此鼠标移动收集的熵应约为8位（因为2 ^ 8 = 255）。另一个示例：如果要求用户考虑一个[0 ... 1000]范围内的数字，则该数字将保留大约9-10位的熵（因为2 ^ 10 = 1024）。为了收集256位的熵（例如安全地生成256位的整数），您将需要考虑一系列此类事件的序列（例如用户的鼠标移动和键盘干扰）。
收集熵
可以从计算机中许多难以预测的事件中收集熵：键盘点击，鼠标移动，网络活动，相机活动，麦克风活动等，以及它们发生的时间。初始随机性的收集通常是由操作系统（OS）在内部执行的，该操作系统提供了标准API来访问它（例如，从Linux中的/ dev / random文件读取）。在台式机系统中，笔记本电脑或手机的熵很容易收集，而在某些有限的硬件设备（例如简单的微控制器）上，熵很难收集或不可能收集。
应用软件可以通过要求用户移动鼠标，在键盘上键入内容，在麦克风上说某些内容或在相机前面移动一会儿来明确地收集熵。一个很好的例子是bitaddress.org钱包应用程序，该应用程序将鼠标移动与键盘事件结合在一起以收集熵：

随机和密码学
请记住，如果没有不可预测的随机性，加密将无法工作！如果您的随机数生成器遭到破坏，它将生成可预测的数字，并且破解者将能够解密您的通信，泄露您的私钥，篡改您的数字签名等。作为开发人员，您应该始终关心如何在密码中生成随机数您使用的库。
CSPRNG（密码学安全随机数生成器）
根据定义，CSPRNG（密码学安全随机数发生器）是一种伪随机数发生器（PRNG），其特性使其适合用于密码学。要使PRNG成为CSPRNG，有两个主要要求：
满足下一个比特测试：如果某人从PRNG开始就知道所有k个比特，那么他将无法使用合理的计算资源来预测k + 1个比特。
承受状态折衷扩展：如果攻击者猜测PRNG的内部状态或以某种方式被泄露，则攻击者应该无法在启示之前重建所有先前的随机数。
操作系统中的熵通常数量有限，并且等待更多的熵是缓慢且不切实际的。大多数密码应用程序使用CSPRNG，CSPRNG会将来自操作系统的可用熵“扩展”到更多位，这是加密目的所必需的，并且符合上述CSPRNG要求。
已提出许多设计来构造CSPRNG算法：
CSPRNG基于计数器模式下的安全块密码，流密码或安全的安全哈希函数。
CSPRNG基于数论，依赖于整数分解问题（IFP），离散对数问题（DLP）或椭圆曲线离散对数问题（ECDLP）的难度。
CSPRNG基于用于加密安全随机性的特殊设计，例如在MacOS和FreeBSD中使用的Yarrow算法和Fortuna。
大多数CSPRNG结合使用来自操作系统和高质量PRNG生成器的熵，它们经常“重新设定”，这意味着当新的熵来自操作系统时（例如，来自用户输入，系统中断，磁盘I / O或硬件随机产生）。生成器），基础PRNG根据即将到来的新熵位来更改其内部状态。随着时间的推移，这种不断的播种使CSPRNG变得非常难以预测和分析。

密码学安全伪随机数生成器（CSPRNG）是随机生成器，它保证了来自它们的随机数绝对不可预测。 CSPRNG满足下一位测试的要求，并且可以承受状态破坏的扩展，通常属于操作系统的一部分，或来自安全的外部来源。根据所需的安全级别，CSPRNG可以实现为软件组件或硬件设备，或两者的组合。
例如，在信用卡打印中心，正式的安全法规要求使用经过认证的硬件随机生成器来生成信用卡PIN码，私钥和其他旨在保持私密性的数据。
现代操作系统（OS）从环境噪声中收集熵（初始种子）：键盘单击，鼠标移动，网络活动，系统I / O中断，硬盘活动等。例如，Linux中环境的随机源，包括键盘间定时，某些中断产生的中断间定时以及其他不确定性的事件，这些事件对于外部观察者而言都是不确定的。
通常可以从/ dev / random和/ dev / urandom访问操作系统中收集的随机性。
从/ dev / random文件（有限阻塞的随机生成器）中读取数据会从内核的熵池（收集的噪声）中返回熵，并在熵池为空时阻塞，直到收集到其他环境噪声为止。
读取/ dev / urandom文件（无限制的非阻塞随机生成器）会从内核的熵池或由先前收集的环境噪声生成的伪随机数据返回熵，这也是不可预测的，但基于安全熵“拉伸” ”算法。
通常，CSPRNG应该从操作系统，专用硬件或外部源的不可预测的随机种子开始。种子初始化后的随机数通常由伪随机计算产生，但这不会影响安全性。大多数算法通常会在出现新的熵时“重新播种” CSPRNG随机生成器，以使其工作更加不可预测。
通常，现代OS CSPRNG API将来自环境的不断收集的熵与其内置伪随机算法的内部状态结合起来，并进行连续重新播种，以确保生成的随机性具有最大的不可预测性，同时具有高速和无阻塞行为。
硬件随机发生器（TRNG）
硬件随机发生器，称为真随机数发生器（TRNG），通常捕获物理过程或现象，例如光的可见光谱，环境的热噪声，大气噪声等。物理环境的随机性是通过专门的传感器收集，然后由设备进行放大和处理，最后通过USB，PCI Express或其他标准接口传输到计算机。
现代微处理器（CPU）提供了内置的硬件随机发生器，可通过特殊的CPU指令RdRand访问该发生器，该指令将随机整数返回到CPU寄存器之一。
如今，大多数加密应用程序都不需要硬件随机数生成器，因为操作系统中的熵对于常规加密目的而言足够安全。对于具有较高安全性要求的系统（例如银行和金融应用程序，证书颁发机构和大额付款处理者），需要使用TRNG。